# Maximum Covering Location Problem (MCLP) Environment

## ğŸ“š é—®é¢˜æè¿°

MCLPï¼ˆMaximum Covering Location Problemï¼Œæœ€å¤§è¦†ç›–é€‰å€é—®é¢˜ï¼‰æ˜¯ä¸€ä¸ªç»å…¸çš„è®¾æ–½é€‰å€ä¼˜åŒ–é—®é¢˜ã€‚

### é—®é¢˜å®šä¹‰

ç»™å®šï¼š
- **éœ€æ±‚ç‚¹é›†åˆ**ï¼šNä¸ªéœ€æ±‚ç‚¹ï¼Œæ¯ä¸ªéœ€æ±‚ç‚¹æœ‰ä½ç½®å’Œéœ€æ±‚é‡ï¼ˆæƒé‡ï¼‰
- **å€™é€‰è®¾æ–½ç‚¹é›†åˆ**ï¼šMä¸ªå€™é€‰è®¾æ–½ä½ç½®
- **è¦†ç›–åŠå¾„**ï¼šrï¼Œè®¾æ–½èƒ½å¤Ÿè¦†ç›–è·ç¦»â‰¤rçš„éœ€æ±‚ç‚¹
- **çº¦æŸ**ï¼šéœ€è¦é€‰æ‹©Kä¸ªè®¾æ–½

ç›®æ ‡ï¼š
- **æœ€å¤§åŒ–**è¢«è¦†ç›–çš„éœ€æ±‚æ€»é‡
- éœ€æ±‚ç‚¹åªæœ‰åœ¨è·ç¦»è‡³å°‘ä¸€ä¸ªå·²é€‰è®¾æ–½â‰¤ræ—¶æ‰è¢«è¦†ç›–
- è¢«å¤šä¸ªè®¾æ–½è¦†ç›–çš„éœ€æ±‚ç‚¹åªè®¡ç®—ä¸€æ¬¡

### æ•°å­¦è¡¨è¾¾

```
è¾“å…¥ï¼š
- demand_locs: Nä¸ªéœ€æ±‚ç‚¹ä½ç½®
- demand_weights: Nä¸ªéœ€æ±‚ç‚¹æƒé‡ w_i
- facility_locs: Mä¸ªå€™é€‰è®¾æ–½ä½ç½®
- coverage_radius: è¦†ç›–åŠå¾„ r
- K: è¦é€‰æ‹©çš„è®¾æ–½æ•°é‡

å†³ç­–å˜é‡ï¼š
- x_j âˆˆ {0,1}: è®¾æ–½jæ˜¯å¦è¢«é€‰æ‹©
- y_i âˆˆ {0,1}: éœ€æ±‚ç‚¹iæ˜¯å¦è¢«è¦†ç›–

ç›®æ ‡å‡½æ•°ï¼š
maximize: Î£_i w_i * y_i

çº¦æŸæ¡ä»¶ï¼š
1. Î£_j x_j = K  (æ°å¥½é€‰æ‹©Kä¸ªè®¾æ–½)
2. y_i â‰¤ Î£_j{d(i,j)â‰¤r} x_j  (éœ€æ±‚ç‚¹iåªæœ‰åœ¨è‡³å°‘ä¸€ä¸ªå·²é€‰è®¾æ–½è¦†ç›–èŒƒå›´å†…æ‰è¢«è¦†ç›–)
3. x_j âˆˆ {0,1}, y_i âˆˆ {0,1}
```

## ğŸ¯ ä¸å…¶ä»–é—®é¢˜çš„åŒºåˆ«

| é—®é¢˜ | ç›®æ ‡ | è¦†ç›–å®šä¹‰ | åº”ç”¨åœºæ™¯ |
|------|------|----------|----------|
| **FLP** | æœ€å°åŒ–è·ç¦» | æ‰€æœ‰éœ€æ±‚éƒ½è¢«æœåŠ¡ | ç‰©æµé…é€ã€é›¶å”®é€‰å€ |
| **MCLP** | æœ€å¤§åŒ–è¦†ç›–éœ€æ±‚ | åŠå¾„å†…éœ€æ±‚è¢«è¦†ç›– | åº”æ€¥è®¾æ–½ã€åŸºç«™å¸ƒå±€ |
| **MCP** | æœ€å¤§åŒ–è¦†ç›–æƒé‡ | æŠ½è±¡é›†åˆè¦†ç›– | èµ„æºåˆ†é…ã€ä»»åŠ¡è°ƒåº¦ |

### MCLPçš„ç‰¹ç‚¹

1. **ç¡¬è¦†ç›–çº¦æŸ**ï¼šè¶…å‡ºåŠå¾„çš„éœ€æ±‚å®Œå…¨ä¸è¢«æœåŠ¡
2. **äºŒå…ƒè¦†ç›–**ï¼šéœ€æ±‚è¦ä¹ˆè¢«è¦†ç›–ï¼ˆ1ï¼‰ï¼Œè¦ä¹ˆä¸è¢«è¦†ç›–ï¼ˆ0ï¼‰
3. **ç©ºé—´æ€§è´¨**ï¼šåŸºäºæ¬§æ°è·ç¦»çš„åœ°ç†ä½ç½®é—®é¢˜
4. **èµ„æºæœ‰é™**ï¼šåªèƒ½é€‰æ‹©Kä¸ªè®¾æ–½

## ğŸ’» ä½¿ç”¨æ–¹æ³•

### åŸºæœ¬ä½¿ç”¨

```python
from rl4co.envs.graph import MCLPEnv
from rl4co.utils.decoding import random_policy, rollout

# åˆ›å»ºç¯å¢ƒ
env = MCLPEnv(generator_params={
    "num_demand": 50,           # éœ€æ±‚ç‚¹æ•°é‡
    "num_facility": 30,         # å€™é€‰è®¾æ–½æ•°é‡
    "num_facilities_to_select": 8,  # é€‰æ‹©è®¾æ–½æ•°é‡
    "min_demand": 1.0,          # æœ€å°éœ€æ±‚æƒé‡
    "max_demand": 10.0,         # æœ€å¤§éœ€æ±‚æƒé‡
    "coverage_radius": 0.2,     # è¦†ç›–åŠå¾„
})

# ç”Ÿæˆé—®é¢˜å®ä¾‹
batch_size = 4
td = env.reset(batch_size=[batch_size])

# ä½¿ç”¨éšæœºç­–ç•¥æµ‹è¯•
reward, td_final, actions = rollout(env, td, random_policy)

print(f"Mean reward: {reward.mean().item():.2f}")
print(f"Coverage: {td_final['is_covered'].float().mean().item()*100:.1f}%")
```

### è§‚æµ‹ç©ºé—´

TensorDictåŒ…å«ä»¥ä¸‹å­—æ®µï¼š

```python
{
    # é™æ€é—®é¢˜æ•°æ®
    "demand_locs": [batch, num_demand, 2],          # éœ€æ±‚ç‚¹ä½ç½®
    "facility_locs": [batch, num_facility, 2],      # å€™é€‰è®¾æ–½ä½ç½®
    "demand_weights": [batch, num_demand],          # éœ€æ±‚æƒé‡
    "coverage_radius": [batch, 1],                  # è¦†ç›–åŠå¾„
    "distance_matrix": [batch, num_demand, num_facility],  # è·ç¦»çŸ©é˜µ
    "num_facilities_to_select": [batch, 1],         # è¦é€‰æ‹©çš„è®¾æ–½æ•°é‡
    
    # åŠ¨æ€çŠ¶æ€
    "chosen": [batch, num_facility],                # å·²é€‰è®¾æ–½ (bool)
    "covered_demand": [batch, num_demand],          # å·²è¦†ç›–éœ€æ±‚æƒé‡
    "is_covered": [batch, num_demand],              # éœ€æ±‚æ˜¯å¦è¢«è¦†ç›– (bool)
    "i": [batch],                                   # å½“å‰æ­¥æ•°
    "action_mask": [batch, num_facility],           # åˆæ³•åŠ¨ä½œæ©ç 
}
```

### åŠ¨ä½œç©ºé—´

- **åŠ¨ä½œç±»å‹**ï¼šç¦»æ•£
- **åŠ¨ä½œèŒƒå›´**ï¼š`[0, num_facility-1]`
- **å«ä¹‰**ï¼šé€‰æ‹©ä¸€ä¸ªå€™é€‰è®¾æ–½
- **çº¦æŸ**ï¼šä¸èƒ½é‡å¤é€‰æ‹©å·²é€‰è®¾æ–½ï¼ˆé€šè¿‡`action_mask`ï¼‰

### å¥–åŠ±å‡½æ•°

```python
reward = sum(demand_weights[i] * is_covered[i] for all i)
```

- å¥–åŠ± = è¢«è¦†ç›–éœ€æ±‚ç‚¹çš„æƒé‡æ€»å’Œ
- éœ€æ±‚ç‚¹è¢«è¦†ç›– âŸº è·ç¦»è‡³å°‘ä¸€ä¸ªå·²é€‰è®¾æ–½ â‰¤ è¦†ç›–åŠå¾„
- è¶Šé«˜è¶Šå¥½

## ğŸ”§ å®ç°ç»†èŠ‚

### è¦†ç›–è®¡ç®—

```python
# 1. è®¡ç®—å“ªäº›éœ€æ±‚åœ¨å“ªäº›è®¾æ–½çš„è¦†ç›–èŒƒå›´å†…
within_radius = distance_matrix <= coverage_radius  # [B, N, M]

# 2. æ£€æŸ¥éœ€æ±‚æ˜¯å¦è¢«ä»»æ„å·²é€‰è®¾æ–½è¦†ç›–
is_covered = (within_radius & chosen.unsqueeze(1)).any(dim=-1)  # [B, N]

# 3. è®¡ç®—è¦†ç›–çš„éœ€æ±‚æƒé‡
covered_demand = demand_weights * is_covered.float()
```

### å…³é”®ç‰¹æ€§

1. **é«˜æ•ˆè¦†ç›–æ›´æ–°**ï¼šä½¿ç”¨å‘é‡åŒ–æ“ä½œè®¡ç®—è¦†ç›–çŠ¶æ€
2. **è·ç¦»é¢„è®¡ç®—**ï¼šåœ¨åˆå§‹åŒ–æ—¶è®¡ç®—å®Œæ•´è·ç¦»çŸ©é˜µ
3. **åŠ¨æ€æ©ç **ï¼šé˜²æ­¢é‡å¤é€‰æ‹©è®¾æ–½

## ğŸ“Š å¯è§†åŒ–ç¤ºä¾‹

è¿è¡Œæµ‹è¯•è„šæœ¬ä¼šç”Ÿæˆå¯è§†åŒ–å›¾ç‰‡ï¼š

```bash
python tests/test_mclp_env.py
```

ç”Ÿæˆçš„å¯è§†åŒ–åŒ…æ‹¬ï¼š
- ğŸ”µ **è“è‰²æ˜Ÿæ˜Ÿ**ï¼šå·²é€‰æ‹©çš„è®¾æ–½
- ğŸ”µ **æµ…è“è‰²åœ†åœˆ**ï¼šè¦†ç›–åŠå¾„èŒƒå›´
- ğŸŸ¢ **ç»¿è‰²åœ†ç‚¹**ï¼šè¢«è¦†ç›–çš„éœ€æ±‚ç‚¹ï¼ˆé¢œè‰²æ·±åº¦è¡¨ç¤ºæƒé‡ï¼‰
- ğŸ”´ **çº¢è‰²å‰å·**ï¼šæœªè¢«è¦†ç›–çš„éœ€æ±‚ç‚¹
- â¬œ **ç°è‰²æ–¹å—**ï¼šæœªé€‰æ‹©çš„å€™é€‰è®¾æ–½

## ğŸ¯ åº”ç”¨åœºæ™¯

### 1. åº”æ€¥æœåŠ¡é€‰å€
- **æ¶ˆé˜²ç«™**ï¼š5åˆ†é’Ÿå“åº”æ—¶é—´åŠå¾„
- **æ•‘æŠ¤ç«™**ï¼š8åˆ†é’Ÿå“åº”æ—¶é—´åŠå¾„
- **è­¦å¯Ÿå±€**ï¼šå¿«é€Ÿå“åº”è¦†ç›–

### 2. é€šä¿¡ç½‘ç»œ
- **åŸºç«™å¸ƒå±€**ï¼šä¿¡å·è¦†ç›–èŒƒå›´
- **WiFiçƒ­ç‚¹**ï¼šè¦†ç›–åŠå¾„
- **ä¸­ç»§ç«™**ï¼šé€šä¿¡èŒƒå›´

### 3. å…¬å…±è®¾æ–½
- **å…¬å›­è§„åˆ’**ï¼šæœåŠ¡èŒƒå›´
- **å›¾ä¹¦é¦†**ï¼šå¯è¾¾è·ç¦»
- **å……ç”µæ¡©**ï¼šè¦†ç›–èŒƒå›´

### 4. é›¶å”®é€‰å€
- **ä¾¿åˆ©åº—**ï¼šæ­¥è¡Œå¯è¾¾èŒƒå›´
- **å¿«é€’ç‚¹**ï¼šé…é€åŠå¾„
- **æœåŠ¡ç½‘ç‚¹**ï¼šæœåŠ¡èŒƒå›´

## ğŸ“ˆ æ€§èƒ½ä¼˜åŒ–

### æ‰¹é‡å¤„ç†
```python
# æ”¯æŒæ‰¹é‡ç”Ÿæˆå’Œè¯„ä¼°
td = env.reset(batch_size=[128])
# é«˜æ•ˆå¹¶è¡Œå¤„ç†
```

### GPUåŠ é€Ÿ
```python
# è‡ªåŠ¨ä½¿ç”¨GPUï¼ˆå¦‚æœå¯ç”¨ï¼‰
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
td = td.to(device)
```

## ğŸ§ª æµ‹è¯•éªŒè¯

æµ‹è¯•è¦†ç›–ï¼š
- âœ… ç¯å¢ƒåˆ›å»ºå’Œåˆå§‹åŒ–
- âœ… é—®é¢˜å®ä¾‹ç”Ÿæˆ
- âœ… éšæœºç­–ç•¥rollout
- âœ… å¥–åŠ±è®¡ç®—æ­£ç¡®æ€§
- âœ… çº¦æŸæ»¡è¶³æ£€æŸ¥
- âœ… è§£å†³æ–¹æ¡ˆå¯è§†åŒ–

## ğŸ“ å‚è€ƒæ–‡çŒ®

1. Church, R., & ReVelle, C. (1974). "The maximal covering location problem". Papers of the Regional Science Association, 32(1), 101-118.
2. Daskin, M. S. (2008). "What you should know about location modeling". Naval Research Logistics, 55(7), 583-585.
3. Farahani, R. Z., et al. (2012). "Covering problems in facility location: A review". Computers & Industrial Engineering, 62(1), 368-407.

## ğŸ”— ç›¸å…³ç¯å¢ƒ

- `FLPEnv`: Facility Location Problem (æœ€å°åŒ–è·ç¦»)
- `MCPEnv`: Maximum Coverage Problem (æŠ½è±¡é›†åˆè¦†ç›–)
- `STPEnv`: Steiner Tree Problem (æœ€å°ç”Ÿæˆæ ‘)
